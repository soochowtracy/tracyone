<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[TracyOne's Blog]]></title>
  <subtitle><![CDATA[HoHo~ 萌萌da技术博客!!!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tracyone.com/"/>
  <updated>2014-10-05T04:39:25.320Z</updated>
  <id>http://tracyone.com/</id>
  
  <author>
    <name><![CDATA[Tracy One]]></name>
    <email><![CDATA[soochowtracy@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Auto Layout&Size Classes]]></title>
    <link href="http://tracyone.com/2014/10/05/Auto-Layout&Size-Classes/"/>
    <id>http://tracyone.com/2014/10/05/Auto-Layout&Size-Classes/</id>
    <published>2014-10-05T04:38:08.000Z</published>
    <updated>2014-10-05T04:39:19.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>我感觉这是一个划时代的布局计数，真正的把机器语言转换成了符合人类的语言。在过去，我们布局都是去设定这个控件的起始坐标和宽高，这其实是很不友好的，比如说，你从来不会说我家的沙发是在客厅的（0，0）坐标开始，往东长3米，往南长2米，这种很奇怪的描述位置的话。更多的你会选择说，靠墙，1米宽，等这种很符合人类思考的话描述。</p>
<a id="more"></a>

<p>应该说Auto Layout其实已经解决了绝大数布局上的问题，不过呢，在某些方面，也有一定的局限性。比如说，在竖屏的时候你想要展示一个tableView，而在横屏时，由于屏幕变宽，想展示collectionView，那么Auto Layout是很难解决这个问题的。也因此，在这次IOS8中新加入了一个成员Size Classes。</p>
<p>SizeClass解决了那些差异化设计，并且很简单的能适配ipad，watch等，甚至一行代码都不需要写。不再根据设备屏幕的具体尺寸来进行区分，而是通过它们的感官表现，将其分为普通 (Regular) 和紧密 (Compact) 两个种类 (class)。开发者便可以无视具体的尺寸，而是对这这两类和它们的组合进行适配。</p>
<h3 id="Auto_Layout">Auto Layout</h3>
<h4 id="代码实现">代码实现</h4>
<pre><code>NSDictionary *viewsDictionary =
                NSDictionaryOfVariableBindings(self.button1, self.button2);
NSArray *constraints =
        [NSLayoutConstraint constraintsWithVisualForma<span class="variable">t:</span>@<span class="string">"[button1]-[button2]"</span>
                            option<span class="variable">s:0</span> metric<span class="variable">s:nil</span> <span class="keyword">view</span><span class="variable">s:viewsDictionary</span>];
</code></pre><p>再举几个可视化语法例子：</p>
<ul>
<li>[aButton(50)]-50-[bButton(50)]<br>a按钮宽50，b按钮宽50，间距50</li>
<li>[aButton(&gt;=50@1000)]<br>aButton宽度大于等于50，优先级为1000</li>
<li>V:[aButton][bButton(==aButton)]<br>竖直布局，a，b两个button等高</li>
<li>H:|-[aButton]<br>水平布局，aButton与左边距默认距离</li>
</ul>
<h4 id="一点点心得">一点点心得</h4>
<p>在考虑布局时，不应该再和以前一样先去考虑初始坐标，长宽等，其实UI设计描述的语句基本是正确的，比如，这两个Button等宽等等，这就是一种约束。</p>
<p>多个组件布局时可以考虑把几个零散的组件放到同一个view中，然后再用view和其他组件建立约束。</p>
<p>布局时先从一些比较固定的组件入手，从简单到复杂，在设计动画的时候不要忘了加 [view layoutIfNeeded]。</p>
<h4 id="流程">流程</h4>
<p>使用AutoLayout之后，把view显示到屏幕上面大体分成3步。</p>
<ul>
<li>Update constraints</li>
<li>Layout views</li>
<li>Display</li>
</ul>
<p>一般来说layoutSubviews负责布局，比如调整View之间的距离，大小，drawRect负责绘制，比如使用什么颜色。而AutoLayout则是在layout之前增加了一个设定约束的过程,也就是update constraints。</p>
<h3 id="总结">总结</h3>
<p>总的来说，iOS对UI这块的改动是跨时代性的，Autolayout的出现使得布局的复杂度减少到了View与View的关系上，再由根 View（也就是屏幕）指定frame，随后所有子View相对布局，把frame的概念归一化到根View的frame上；但有了Size Class后，根视图的frame概念也被移除了，这下整个app的UI和frame这个单词已然脱离关系，这也正是apple想要达到的目的。</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>我感觉这是一个划时代的布局计数，真正的把机器语言转换成了符合人类的语言。在过去，我们布局都是去设定这个控件的起始坐标和宽高，这其实是很不友好的，比如说，你从来不会说我家的沙发是在客厅的（0，0）坐标开始，往东长3米，往南长2米，这种很奇怪的描述位置的话。更多的你会选择说，靠墙，1米宽，等这种很符合人类思考的话描述。</p>
]]></summary>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="auto layout" scheme="http://tracyone.com/tags/auto-layout/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数式编程]]></title>
    <link href="http://tracyone.com/2014/09/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://tracyone.com/2014/09/26/函数式编程/</id>
    <published>2014-09-26T15:26:35.000Z</published>
    <updated>2014-09-26T15:29:56.000Z</updated>
    <content type="html"><![CDATA[<p>从接触编程到现在，也接触过很多编程范式，从入门级的面向结构，到现在如日中天的面向对象，还有在web开发中很流行的面向切面的编程思想等。这一次要介绍的主题是：函数式的编程思想。</p>
<p>Native app有很大一部分的时间是在等待事件发生，然后响应事件，比如等待网络请求完成，等待用户的操作，等待某些状态值的改变等等，等这些事件发生后，再做进一步处理。 但是这些等待和响应，并没有一个统一的处理方式。Delegate, Notification, Block, KVO, 常常会不知道该用哪个最合适。</p>
<a id="more"></a>

<h3 id="基础中的基础">基础中的基础</h3>
<p>举个例子最清晰：</p>
<p><code>a(x) = x*x;
b(x) = x+1;
a(b(x)) = (x+1)*(x+1)</code></p>
<p>只要上过初中的都知道，多么简单的一堆函数，其实函数式编程就是这么简单，在IOS中也很容易实现（多亏了block）。先简单介绍下block，一句话总结就是，带有自动变量的匿名函数。</p>
<h5 id="什么是Blocks">什么是Blocks</h5>
<p>Block语法和一般的C语言函数定义只有两点不同：</p>
<ol>
<li>没有函数名</li>
<li>带有^符号</li>
</ol>
<h5 id="Block类型变量">Block类型变量</h5>
<p>声明Block变量比较麻烦，所以建议用 </p>
<blockquote>
<p>typedef int (^blk)(int)</p>
</blockquote>
<p>这种来简化声明。</p>
<p>在Block中保存的局部变量是在创建该Block瞬间的局部变量，并且还是常量，所以理论上来说是不能改变它的值的。不过可以通过__block来声明成readwrite，达到改变局部变量的值的效果。</p>
<h5 id="Block注意点">Block注意点</h5>
<p>其实Block中保存的是对象的结构体指针，也就是说如果你截获了一个Array对象，你只是往里面添加对象，其实是可以的，而无果是要重新指向另外一个array就crash了，另外，对c语言数组的截获是没有实现的。</p>
<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (retain cycles) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。</p>
<h3 id="基于Block的FRP">基于Block的FRP</h3>
<p>写个最简单的例子：</p>
<ul>
<li><p>这是比较普通的实现:</p>
<pre><code>   -(<span class="keyword">IBAction</span>)showAlertViewPressed:(<span class="keyword">id</span>)sender {
  UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:<span class="string">@"test"</span> message:<span class="literal">nil</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@"Cancel"</span> otherButtonTitles: <span class="literal">nil</span>];

  [alertView show];
</code></pre><p>  }</p>
<pre><code>  -(<span class="keyword">void</span>)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex{
      <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) {
          <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);
      }
  }
</code></pre></li>
<li><p>这是基于函数式的：</p>
<p>  -(IBAction)showAlertViewPressed:(id)sender {</p>
<pre><code>  UIAlertView *alertView = [[UIAlertView alloc] initAlertViewWithTitle:<span class="string">@"test"</span> message:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"Cancel"</span> otherButtonTitles: <span class="literal">nil</span> onCancelCompletion:^{
      <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);
  }];
  [alertView show];
</code></pre><p>  }</p>
</li>
</ul>
<p>这是比较简单的一个例子，不过基本能够感觉出来什么是基于函数式的编程了。</p>
<p>再看一个比较经典的网络请求中的函数式编程：</p>
<pre><code><span class="attr_selector">[[NSURLSession sharedSession]</span> downloadTaskWithURL<span class="value">:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {
    dispatch_queue_t queue = <span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span>
    <span class="function">dispatch_async</span>(queue, ^{
        <span class="comment">//在这里对下载好的数据进行处理</span>

        <span class="function">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
            <span class="comment">//用处理好的数据渲染页面等。</span>
        });
    });

}];
</code></pre><p>在这里不推荐大家网路请求也在其他线程中，会引发很多问题，比如说线程栈内存耗尽，用系统自带的异步请求就ok了。</p>
<h3 id="新工作初体验">新工作初体验</h3>
<p>来到同程，也已经一个月了，刚入职还似在眼前，从对整个客户端的一无所知，到现在能够贡献自己的一份力，收获颇丰。在这样一个简单而又不简单的团队中，在这样一种简单的氛围中，对于个人的成长是非常有利的。不得不说，在这样的环境中，能够使人飞速成长，也在这里感谢每一个帮助我，督促我不断前行的每一个人。</p>
<p>再给自己定一个目标，每个月看一本书，无关是否技术类，贵在坚持！</p>
]]></content>
    <summary type="html"><![CDATA[<p>从接触编程到现在，也接触过很多编程范式，从入门级的面向结构，到现在如日中天的面向对象，还有在web开发中很流行的面向切面的编程思想等。这一次要介绍的主题是：函数式的编程思想。</p>
<p>Native app有很大一部分的时间是在等待事件发生，然后响应事件，比如等待网络请求完成，等待用户的操作，等待某些状态值的改变等等，等这些事件发生后，再做进一步处理。 但是这些等待和响应，并没有一个统一的处理方式。Delegate, Notification, Block, KVO, 常常会不知道该用哪个最合适。</p>
]]></summary>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="block" scheme="http://tracyone.com/tags/block/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MRC&ARC进阶]]></title>
    <link href="http://tracyone.com/2014/09/23/MRC&ARC%E8%BF%9B%E9%98%B6/"/>
    <id>http://tracyone.com/2014/09/23/MRC&ARC进阶/</id>
    <published>2014-09-23T13:10:00.000Z</published>
    <updated>2014-09-23T13:31:26.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司项目不再需要适配ios5了（3q God），终于可以使用一些比较吊的特性了，比如说Auto Layout，不过呢，这次的主题是在ios5中就有的ARC，乘着这次改版，顺带巩固和学习下ios的内存管理。</p>
<h3 id="谈谈苹果使用过的内存管理策略">谈谈苹果使用过的内存管理策略</h3>
<ol>
<li>手动引用计数（MRC）：每个对象都有一个retain计数，当retain为0的时候释放对象。</li>
<li>垃圾回收机制（GC）：主要是监视整个对象关系图，查找那些作用域内没有任何引用的对象，然后释放。</li>
<li>自动引用计数（ARC）：也是基于手动引用计数的，不过编译器来管理。</li>
</ol>
<p>之所以要引入ARC，主要是因为，手动引用计数需要手动进行，增加工作量，开发时需要显示的retain和release，而且容易循环retain；而垃圾回收机制容易产生性能损耗，更何况是在手机上。</p>
<a id="more"></a>

<h3 id="简要说说MRC">简要说说MRC</h3>
<ul>
<li>给对象发送release消息并不会销毁对象，只有在retain计数为0的时候，才会调用dealloc方法，来释放内存。</li>
<li>对使用了retain，copy，alloc，new的任何对象和属性，需要覆盖dealloc方法，使得对象在释放的时候能够先释放这些实例变量。</li>
<li>autorelease比较常用的几种方式：</li>
</ul>
<ol>
<li>方法返回值，由于会retain返回的对象，而又需要释放</li>
<li>在循环中，如果需要创建大量零时对象，建议用autorelease</li>
</ol>
<ul>
<li>比较常用的Accessor方法有这些：</li>
</ul>
<blockquote>
<p>-(void)setFoo:(NSString *)foo{<br>    if (_foo != foo){<br>        [_foo release];<br>        _foo = [foo retain];<br>    } }</p>
<p>-(void)setFoo:(NSString *)foo{<br>        [_foo retain];<br>        [_foo release];<br>        _foo = foo; }</p>
<p>-(void)setFoo:(NSString *)foo{<br>        [_foo autorelease];<br>        _foo = [foo retain]; }</p>
</blockquote>
<p>第二个方法千万不能先release再retain，如果是同一个对象，恰好retain只有1，那么就crash啦。三个方法各有利弊吧，我比较喜欢用第一个。</p>
<h3 id="内存管理的实现">内存管理的实现</h3>
<ol>
<li>id obj = [NSObject alloc]：</li>
</ol>
<blockquote>
<p>struct obj_layout{<br>    NSUInteger retained; }</p>
<p>+(id)alloc{<br>    int size = sizeOf(struct obj_layout) + 对象大小;<br>    struct obj_layout <em>p = (struct obj_layout </em>)calloc(1,size);<br>    return (id)(p + 1); }</p>
</blockquote>
<ol>
<li>[obj retain]：</li>
</ol>
<blockquote>
<p>-(id)retain{<br>    NSIncrementExtraRefCount(self);<br>    return self; }<br>inline void NSIncrementExtraRefCount(id anObject){<br>    ((struct obj_layout *)anObjcet)[-1].retained++; }</p>
</blockquote>
<ol>
<li>[obj release]：</li>
</ol>
<blockquote>
<p> -(id)release{<br>     if(NSDocumentExtraRefCountWasZero(self)){<br>            [self dealloc];<br>     }  }<br>BOOL NSDocumentExtraRefCountWasZero(id anObject){<br>    if(((struct obj_layout <em>)anObjcet)[-1].retained == 0){<br>        return YES;<br>    }else{<br>        ((struct obj_layout </em>)anObjcet)[-1].retained—;<br>        return NO;<br>    } }</p>
</blockquote>
<ol>
<li>dealloc：</li>
</ol>
<blockquote>
<p> -dealloc{<br>    NSDeallocateObject(self); } inline void NSDeallocateObject(id anObject){<br>    struct obj_layout <em>o = &amp;((struct obj_layout </em>)anObjcet)[-1];<br>    free(o); }</p>
</blockquote>
<p>总结一下，其实就是在指向对象的指针地址向低地址便宜一个retain结构体的大小，期间存放retain计数，然后alloc和retain＋1，而release如果已经为0则调用dealloc方法，否则retain－1，最终在dealloc中释放掉对象。</p>
<h3 id="MRC转ARC的难点及步骤">MRC转ARC的难点及步骤</h3>
<ol>
<li>Objective-C对象和Core Foundation对象之间的转换，需要恰当的使用CFBridgeRetain/CFBridgeRelease或者_bridge_retained/_bridge_transfer转换。</li>
<li>避免循环引用，block和delegate必须注意weak的使用,NSTimer，还有注册的观察者，在dealloc中需要注销。</li>
</ol>
<p>第一步：<br><img src="/pic/PastedGraphic-1.png" alt="Alt text"></p>
<p>第二步：<br><img src="/pic/PastedGraphic-2.png" alt="Alt text"></p>
<p>第三步：修改错误点；<br><img src="/pic/PastedGraphic-3.png" alt="Alt text"></p>
<h3 id="总结：">总结：</h3>
<ol>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要持有的对象，自己释放</li>
<li>不是自己持有的对象不能释放</li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>最近公司项目不再需要适配ios5了（3q God），终于可以使用一些比较吊的特性了，比如说Auto Layout，不过呢，这次的主题是在ios5中就有的ARC，乘着这次改版，顺带巩固和学习下ios的内存管理。</p>
<h3 id="谈谈苹果使用过的内存管理策略">谈谈苹果使用过的内存管理策略</h3>
<ol>
<li>手动引用计数（MRC）：每个对象都有一个retain计数，当retain为0的时候释放对象。</li>
<li>垃圾回收机制（GC）：主要是监视整个对象关系图，查找那些作用域内没有任何引用的对象，然后释放。</li>
<li>自动引用计数（ARC）：也是基于手动引用计数的，不过编译器来管理。</li>
</ol>
<p>之所以要引入ARC，主要是因为，手动引用计数需要手动进行，增加工作量，开发时需要显示的retain和release，而且容易循环retain；而垃圾回收机制容易产生性能损耗，更何况是在手机上。</p>
]]></summary>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="内存" scheme="http://tracyone.com/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KVC&KVO]]></title>
    <link href="http://tracyone.com/2014/09/09/KVC&KVO/"/>
    <id>http://tracyone.com/2014/09/09/KVC&KVO/</id>
    <published>2014-09-09T13:14:40.000Z</published>
    <updated>2014-09-09T13:23:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>从原理上来说，它的实现根本是OC的动态性和运行时机制，每一门面向对象语言都能在运行时来动态的分配和改变内存。<br>从设计模式的角度来看，KVC/KVO是观察者模式的一种实现，用来降低 model 与 view 的耦合程度；<br>从协议的角度看，它的本质是定义了一套让我们去遵守的方法，在NSObject中实现了NSKeyValueCoding/NSKeyValueObserving的<strong>非正式协议</strong>；</p>
<p><a id="more"></a></p>
<h3 id="KVC用法">KVC用法</h3>
<p><strong>1. key &amp; keyValue</strong></p>
<pre><code><span class="pp">- <span class="params">(id)</span>valueForKey:<span class="params">(<span class="variable">NSString</span> *)</span>key;  
- <span class="params">(void)</span>setValue:<span class="params">(id)</span>value forKey:<span class="params">(<span class="variable">NSString</span> *)</span>key;  
- <span class="params">(id)</span>valueForKeyPath:<span class="params">(<span class="variable">NSString</span> *)</span>keyPath;  
- <span class="params">(void)</span>setValue:<span class="params">(id)</span>value forKeyPath:<span class="params">(<span class="variable">NSString</span> *)</span>keyPath;  </span>
</code></pre><p>前边两个方法用到的Key较容易理解，就是要访问的属性名称对应的字符串。<br>后面两个方法用到的KeyPath是一个被点操作符隔开的用于访问对象的指定属性的字符串序列。比如KeyPath address.street将会访问消息接收对象所包含的address属性中包含的一个street属性。其实KeyPath说白了就是我们平时使用点操作访问某个对象的属性时所写的那个字符串</p>
<p><strong>2. Collection Operators</strong></p>
<pre><code><span class="title">NSNumber</span> *transactionAverage = [transactions valueForKeyPath:@<span class="string">"<span class="variable">@avg</span>.amount"</span>]; 
<span class="title">NSNumber</span> *numberOfTransactions = [transactions valueForKeyPath:@<span class="string">"<span class="variable">@count</span>"</span>];  
</code></pre><p>简单集合运算符共有@avg，@count，@max，@min，@sum5种，都表示啥不用我说了吧，目前还不支持自定义</p>
<h3 id="实现原理">实现原理</h3>
<p><strong>1.KVC如何访问属性值</strong></p>
<p><em>KVC再某种程度上提供了访问器的替代方案。不过访问器方法是一个很好的东西，以至于只要是有可能，KVC也尽量再访问器方法的帮助下工作。为了设置或者返回对象属性，KVC按顺序使用如下技术：<br>①检查是否存在-<key>、-is<key>（只针对布尔值有效）或者-get<key>的访问器方法，如果有可能，就是用这些方法返回值；<br>检查是否存在名为-set<key>:的方法，并使用它做设置值。对于-get<key>和-set<key>:方法，将大写Key字符串的第一个字母，并与Cocoa的方法命名保持一致；<br>②如果上述方法不可用，则检查名为-<em>_<key>，-_is<key>（只针对布尔值有效）,-_get<key>和-_set<key>:方法；<br>③如果没有找到访问器方法，可以尝试直接访问实例变量。实例变量可以是名为：<key>或</key></key></key></key></key></em> _<key>;<br>④如果仍未找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</key></key></key></key></key></key></key></em></p>
<p><strong>2.KVO实现原理</strong></p>
<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>
<p>派生类在被重写的 setter 方法实现真正的通知机制，这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</p>
<p>同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。</p>
<h3 id="KVO和线程">KVO和线程</h3>
<p>一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。没有队列或者 Run-loop 的处理。手动或者自动调用 -didChange… 会触发 KVO 通知。</p>
<p>所以，当我们试图从其他线程改变属性值的时候我们应当十分小心，除非能确定所有的观察者都用线程安全的方法处理 KVO 通知。通常来说，我们不推荐把 KVO 和多线程混起来。如果我们要用多个队列和线程，我们不应该在它们互相之间用 KVO。</p>
<p>KVO 是同步运行的这个特性非常强大，只要我们在单一线程上面运行（比如主队列 main queue），KVO 会保证下列两种情况的发生：</p>
<p>首先，如果我们调用一个支持 KVO 的 setter 方法，如下所示：</p>
<pre><code><span class="attribute">self.exchangeRate </span>=<span class="string"> 2.345;</span>
</code></pre><p>KVO 能保证所有 exchangeRate 的观察者在 setter 方法返回前被通知到。</p>
<p>其次，如果某个键被观察的时候附上了 NSKeyValueObservingOptionPrior 选项，直到 -observe… 被调用之前， exchangeRate 的 accessor 方法都会返回同样的值。</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>从原理上来说，它的实现根本是OC的动态性和运行时机制，每一门面向对象语言都能在运行时来动态的分配和改变内存。<br>从设计模式的角度来看，KVC/KVO是观察者模式的一种实现，用来降低 model 与 view 的耦合程度；<br>从协议的角度看，它的本质是定义了一套让我们去遵守的方法，在NSObject中实现了NSKeyValueCoding/NSKeyValueObserving的<strong>非正式协议</strong>；</p>
<p>]]></summary>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[买车记]]></title>
    <link href="http://tracyone.com/2014/08/18/%E4%B9%B0%E8%BD%A6%E8%AE%B0/"/>
    <id>http://tracyone.com/2014/08/18/买车记/</id>
    <published>2014-08-18T12:13:15.000Z</published>
    <updated>2014-08-19T11:03:05.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>一切都来的太突然，辞职，看房，买车，最近一个礼拜伴随着压抑的缠绵的讨厌的雨，心情也是很沉重。看着父母的愁容，心里也很过意不去，唯有努力工作，好好报答了。</p>
<p>公司离家比较远，不买车也不行了，看过去租房，还是算了，房租也够邮费了，而且以后肯定是两个人生活啊，双人租房好贵的，就这么安慰自己。。。</p>
<p><a id="more"></a></p>
<h3 id="选车">选车</h3>
<p>重点戏来了，与车结下不解之缘是一次做朋友的车，看那中控台，瞬间就中毒，本田的思域那分层设计太合胃口饿。那时候就想以后也买一台思域，那骚包的外观也很有吸引力，然后就和老爸商量，结果老爸说要SUV，好吧，开始关注SUV。。。</p>
<ol>
<li><p>神车途观：不得不说这是我关注最久的一款车型，但是：当我去上海大众的时候，满怀期待的心情进去，失望了，态度差的很，不但不优惠还要加装饰两万多，还要等一个月左右才能有车，像我20多岁的亢奋青年哪里受得了这点，淘汰~~</p>
</li>
<li><p>翼虎：真的很喜欢，差点就定了，那眯起来的眼神，太销魂了，可惜有瘸腿的风险，pass了。</p>
</li>
<li><p>CRV:这个性价比超高，md，结果有个光头先买了，气死了，而且那肥臀也不是我的菜，pass～</p>
</li>
<li><p>CRV4:喜欢就是喜欢，不在乎所谓的公主坟，猪大肠等等，中控台是一直要看到的，最好看的中控。</p>
</li>
</ol>
<h3 id="看车">看车</h3>
<p>直奔4S店，销售很热情，小胡同学真是个不错的人（以后要买丰田的车可以找他），进了展厅，第一眼看到的却是锐志，老妈狂喜欢啊，我其实也蛮喜欢的，不过考虑到我比较魁梧，嗯，就是比较魁梧，还是看看边上的RAV-4了。</p>
<p>第一眼，很霸气，相当霸气，打开门坐进去，高端大气，特别是双拼色，大爱啊。第一天没有定，回家商量下。然后就是各种七大姑，八大姨的建议。最终还是决定，就它了，接下来就是谈价格了，第一次比较紧张，不过在小胡同学的帮助下还是拿到很多优惠，在这里再次感谢小胡同学。</p>
<h3 id="尾记">尾记</h3>
<p>买完车，发现，自动挡不会开，这是个问题，还有万恶的邮费啊，不知道如何赚起。。。不想了，慢慢学，慢慢的，都会好的。</p>
<p>最后感谢以下这些人给我的支持：亲人，还有那个她，还有晓赟同学，虽然最后没有买公爵，下次还是有机会的嘛。</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>一切都来的太突然，辞职，看房，买车，最近一个礼拜伴随着压抑的缠绵的讨厌的雨，心情也是很沉重。看着父母的愁容，心里也很过意不去，唯有努力工作，好好报答了。</p>
<p>公司离家比较远，不买车也不行了，看过去租房，还是算了，房租也够邮费了，而且以后肯定是两个人生活啊，双人租房好贵的，就这么安慰自己。。。</p>
<p>]]></summary>
    
      <category term="生活" scheme="http://tracyone.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内存管理]]></title>
    <link href="http://tracyone.com/2014/08/16/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://tracyone.com/2014/08/16/内存管理/</id>
    <published>2014-08-16T08:03:45.000Z</published>
    <updated>2014-08-16T08:06:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>大学时就已经接触过内存管理，不过和大多数同学一样，感觉没啥用啊，不知道用来干嘛，随着技术那么一丢丢的提升，越发的觉得内存管理的重要性，恰巧这次面试也碰到了，整理了下objective_c中常用的内存管理方式以及一点点自己的心得。</p>
<p><a id="more"></a></p>
<h3 id="一点点基础">一点点基础</h3>
<p>先说说程序运行时内存的分布情况吧：</p>
<ol>
<li>栈：一般的局部变量，函数的行参都是存放在栈中，由操作系统来自动分配和销毁，效率比较高。</li>
<li>堆：运行时才能决定分配大小，由自己来分配和销毁，也是支撑起多态的根本。</li>
<li>代码区：由你编写的代码编译成二进制后存放的区域</li>
<li>常量区：就是常量呀</li>
<li>全局区：全局变量或者静态变量存放的区域</li>
</ol>
<p>内存分配：</p>
<ul>
<li>静态存储区域分配，编译时已知分配大小</li>
<li>在栈上创建   运行时已知分配大小</li>
<li>从堆上分配   运行时还未知。</li>
</ul>
<h3 id="MRC,autoreleasepool，ARC">MRC,autoreleasepool，ARC</h3>
<p>引用计数的内存管理思考方式：</p>
<ol>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要自己持有的对象，自己释放</li>
<li>非自己持有的对象无法释放</li>
</ol>
<h4 id="MRC：">MRC：</h4>
<p>分别对应了NSObject的alloc/retain/release/dealloc操作。</p>
<p>alloc 操作其实调用的是c语言中的calloc操作，在内存快中写入了retain count，并且内容指为nil。retain操作就是加入了异常处理的retaincount++,release操作就是retaincount—，而当retaincount为0的时候，自动调用了free操作，也就是dealloc。</p>
<h4 id="autorelease：">autorelease：</h4>
<p>可以这么理解，autorelease对象就像局部变量一样，在生命周期结束的时候自动释放，不过autorelease对象是可以设定作用域的。</p>
<p>autorelease对象其实就是调用了autoreleasePool对象的addObject方法。而autoreleasePool和局部变量一样在生命周期结束时自动调用drain方法，会release所有持有的对象。</p>
<h4 id="ARC：">ARC：</h4>
<ul>
<li>_strong来强引用对象，能够持有对象</li>
<li>_weak弱引用对象，不能持有，避免循环引用</li>
<li>_unsafe_unretain大多数情况和_weak一样,不过在对象释放时不会指向nil，造成悬空指针（不属于编译器的管理对象）</li>
<li>_autorelease一般不用，不显式注册也能起到作用，使用@autoreleasepool来代NSAutoreleasePool</li>
</ul>
<h3 id="深入内存机制">深入内存机制</h3>
<p>操作系统这本书上解释的很清楚了，其实我也不是很懂。。。就在这里说点闲话了</p>
<p>找工作，尤其是第一份工作需要慎重考虑，薪水不是关键，找准自己的方向，能够切合自己的兴趣更好。总是有舍有得，从今天开始，又是新的一天，</p>
<p>学习最可怕的不是你不努力，而是方向就错了，很庆幸能够找到一条属于自己的路，虽然未来会很坎坷。</p>
<p>（再也不想预测下一篇博客会写什么，貌似没有一次是准的）</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>大学时就已经接触过内存管理，不过和大多数同学一样，感觉没啥用啊，不知道用来干嘛，随着技术那么一丢丢的提升，越发的觉得内存管理的重要性，恰巧这次面试也碰到了，整理了下objective_c中常用的内存管理方式以及一点点自己的心得。</p>
<p>]]></summary>
    
      <category term="内存" scheme="http://tracyone.com/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="ARC" scheme="http://tracyone.com/tags/ARC/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优秀的ios7实践：天气应用学习（上）]]></title>
    <link href="http://tracyone.com/2014/08/06/%E4%BC%98%E7%A7%80%E7%9A%84ios7%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%A4%A9%E6%B0%94%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://tracyone.com/2014/08/06/优秀的ios7实践：天气应用学习（上）/</id>
    <published>2014-08-06T12:18:05.000Z</published>
    <updated>2014-08-06T12:31:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在开头的话">写在开头的话</h3>
<p>整整三个礼拜，曾自信的以为能够翻译全文的，结果还是只完成了上半部分，中间断断续续，不管怎么说还是坚持了下来。就是图片没有，可以参考<a href="http://www.raywenderlich.com/55384/ios-7-best-practices-part-1" target="_blank" rel="external">译文</a> </p>
<p>发现看懂英文和翻译成比较顺口的文章还是有差别的，希望以后能够大大的提高自己的英语口语水平。</p>
<p>还有上次说的ruby计划已经泡汤，不知道合适才能重拾ruby，下一次准备发一篇对设计模式的理解，和最近再研究的<strong>reactivecocoa</strong></p>
<p><a href="http://www.raywenderlich.com/55384/ios-7-best-practices-part-1" target="_blank" rel="external">译文</a> 作者：Ryan Nystrom</p>
<p><a id="more"></a><br>每个开发者对于如何去创建一个优秀的ios应用都有他们的想法。有些开发者利用自动布局，有些喜欢用代码写ui，甚至有些喜欢用vim来编码。</p>
<p>随着最近ios7和xcode5升级，我觉得是时候提供一个教学用多种方法和工具创建一个基础的天气应用；你可以把这看成是我最好的一次ios7实践。ios先驱开发者习惯创建一个待办应用，然而新生代希望像ios的更新一样娴熟的用新的技术，例如，数据管理和网络请求等。</p>
<p> 在这个教程中，你会学会怎么利用下列工具和知识创建你自己的app：</p>
<ul>
<li>Cocoapods</li>
<li>manual layout in code</li>
<li>ReactiveCocoa</li>
<li>OpenWeatherMap</li>
</ul>
<p>这个课程是为那些有一定基础但还没踏入太多高等领域的进阶开发者设计的。它对那些想探索OC实用程序也是一个好的开始。</p>
<h2 id="开始">开始</h2>
<p>打开Xcode到<strong>File\New\Project</strong>。选择<strong>Application\Empty Application</strong>。项目名字     叫<strong>SimpleWeather</strong>，点击<strong>Next</strong>，再选一个目录存放，最后点<strong>Create</strong>。</p>
<p>现在你搭好了基础的项目，下一步开始搭建第三方库，不过先保证你的Xcode是关闭的而不会影响接下来的步骤。</p>
<h3 id="Cocoapods">Cocoapods</h3>
<p>你将会用<strong><a href="http://cocoapods.org" target="_blank" rel="external">Cocoapods</a></strong>管理那些下载的代码，添加文件到你的项目和配置任何你项目需要的设置。让我们先来看看你需要那些项目。</p>
<h3 id="Mantle">Mantle</h3>
<p><strong><a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a></strong> 是由Github团队编写用来清除在oc中nsobject转换成json的样板代码。Mantle也可以把简单的json值转换成复杂的例如NSdate，NSURL，甚至一些自定义的类。</p>
<h3 id="LBBlurredImage">LBBlurredImage</h3>
<p><strong><a href="https://github.com/lukabernardi/LBBlurredImage" target="_blank" rel="external">LBBlurredImage</a></strong>是一个用来处理图片模糊的UIImageView的扩展。你能用一行简单的代码达到模糊效果，如果想知道原理，下载<a href="https://github.com/lukabernardi/LBBlurredImage/blob/master/LBBlurredImage/UIImageView%2BLBBlurredImage.m#L25-88" target="_blank" rel="external">源码</a>。</p>
<h3 id="TSMessages">TSMessages</h3>
<p><strong><a href="https://github.com/toursprung/TSMessages" target="_blank" rel="external">TSMessages</a></strong> 是又一个用来弹出显示警告和通知的轻量级库。当你呈现的错误信息不够清晰的时候，展示一层透明警告栏而不是模板试图（例如 UIAlertView）来尽可能减少用户的反感。</p>
<p>你可以在网络连接失败或者APl引起的其他错误时使用TSMessages。如果出了任何问题，你会看到：</p>
<h3 id="ReactiveCocoa">ReactiveCocoa</h3>
<p>你会用到最后一个也是由Github团队编写的库就是<strong><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a></strong>。它带来了就像.NET中的Reactive Extensions一样在oc 中的一种设计模式，你将会花大量时间来学习它。</p>
<h2 id="设置你的Cocoapods库">设置你的Cocoapods库</h2>
<p>要搭建Cocoapods库，先要确保你已经安装了，为此打开终端，打下列命令然后敲打回车。</p>
<blockquote>
<p>which pod</p>
</blockquote>
<p>你会看到类似下列信息：</p>
<blockquote>
<p>/user/bin/pod</p>
</blockquote>
<p>这取决于你如何管理你的Ruby gems，比如说，如果你用<a href="http://rbenv.org" target="_blank" rel="external">rbenv</a>或者<a href="http://rvm.io" target="_blank" rel="external">RVM</a>那么你的路径可能略有不同。</p>
<p>如果终端返回的是<strong>pod not found</strong>，说明Cocoapods还没安装；按照我们的<a href="http://www.raywenderlich.com/64546/introduction-to-cocoapods-2" target="_blank" rel="external">Cocoapods教程</a>安装，如果你想学习更多那也是一个很好的资源。</p>
<p><a href="http://guides.cocoapods.org/syntax/podfile.html" target="_blank" rel="external">Podfiles</a>用来告诉Cocoapod应该包括哪些Pods，开源项目。</p>
<p>要创建你第一个Cocoapod项目，在终端先用<strong>cd</strong>命令切换到存有你的xcode文件夹。在终端中用vim Podfile写下下列命令：</p>
<blockquote>
<p>platform :ios, ‘7.0’<br>pod ‘Mantle’<br>pod ‘LBBlurredImage’<br>pod ‘TSMessages’<br>pod ‘ReactiveCocoa’</p>
</blockquote>
<p>这个文件会做两件事：</p>
<ul>
<li>告诉Cocoapods你目标版本是哪个，现在这个是ios 7.0。</li>
<li>它也告诉Cocoapods你要引入的一系列项目。</li>
</ul>
<p>打下列命令来安装四个Pods：</p>
<blockquote>
<p>pod install</p>
</blockquote>
<p>耐心的等待pod安装大量的包，最终你的终端会显示下列信息：</p>
<blockquote>
<p>Analyzing dependencies<br>Downloading dependencies<br>Installing HexColors (2.2.1)<br>Installing LBBlurredImage (0.2.0)<br>Installing Mantle (1.5)<br>Installing ReactiveCocoa (2.3.1)<br>Installing TSMessages (0.9.9)<br>Generating Pods project<br>Integrating client project<br>[!] From now on use <code>SimpleWeather.xcworkspace</code>.</p>
</blockquote>
<p>Cocoapods会在你的项目目录中创建一个新的分支；不过你只需要关心<strong>SimpleWeather.xcworkspace</strong>.</p>
<p>打开<strong>SimpleWeather.xcworkspace</strong>，你会看到每个你引入的库和pods项目：</p>
<p>如下图一样确保你选中了<strong>SimpleWeather</strong>项目：</p>
<p>运行一下以确保每件事都顺利进行着：</p>
<p>现在看上去好像不太对，不过你马上就会添加一些内容。</p>
<blockquote>
<p><strong>Note:</strong> 你可能会发现一些警告，那是因为项目中引入了一些其他开发者的库，每个开发者对于警告都有自己的忍耐程度。大多数时间只需要忽略它们，只需要确保没有编译错误！</p>
</blockquote>
<h2 id="创建你的主试图">创建你的主试图</h2>
<p>应用看上去很复杂，其实也就一个试图控制器，接下来你会增加一个。</p>
<p>选中项目，点击<strong>File\New\File</strong>然后选择<strong>CocopTouch\Objective-C</strong>，取名<strong>WXController</strong>，继承<strong>UIViewController</strong>。</p>
<p>确保<strong>Targeted for iPad</strong> 和 <strong>With XIB for user interface</strong>都没选：</p>
<p>打开<strong>WXController.m</strong> 在<strong>-viewDidLoad</strong>方法中如下重写：</p>
<blockquote>
<p> -(void)viewDidLoad{<br>    [super viewDidLoad]<br>    self.view.backgroundColor = [UIColor redColor];<br>}</p>
</blockquote>
<p>然后打开<strong>AppDelegate.m</strong>，引入下列两个类。</p>
<blockquote>
<p>import “WXController.h”<br>import <tsmessage.h></tsmessage.h></p>
</blockquote>
<p>眼尖的读者会发现<strong>WXController</strong>用了双引号而<strong>TSMessage</strong>却是尖括号，有什么区别呢？</p>
<p>回想下在创建Podfile时,你用Cocoapods引入TSMessage。Cocoapods创建了TSMessage项目并加到你的工作区。如果你是从工作区引入其他项目，只需要用尖括号。<br>用下列代码代替 <strong>-application:didFinishLaunchingWithOptions:</strong></p>
<blockquote>
<p>-(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {<br>    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];<br>    // 1<br>    self.window.rootViewController = [[WXController alloc] init];<br>    self.window.backgroundColor = [UIColor whiteColor];<br>    [self.window makeKeyAndVisible];<br>    // 2<br>    [TSMessage setDefaultViewController: self.window.rootViewController];<br>    return YES;<br>}</p>
</blockquote>
<p>随着数字注释你会发现：</p>
<ol>
<li>初始化并把<strong>WXController</strong>设为application的根试图。通常都是一个<strong>UINavigationgController</strong>或者<strong>UItabBarController</strong>，不过在这个应用中，你将用到<strong>WxController</strong>。</li>
<li>设置默认的试图控制器给TSMessage，这样你就不需要经常选择哪个去呈现警告。</li>
</ol>
<p>状态栏在红色的背景中很不清晰，还好有一种比较简单的方法改善。<br>在ios7的<strong>UIViewController</strong>中有个新接口控制状态栏的外观，打开<strong>WXController</strong>在<strong>-viewDidLoad</strong>下面写下这些代码：</p>
<blockquote>
<p>-(UIStatusBarStyle)preferredStatusBarStyle {<br>    return UIStatusBarStyleLightContent;<br>}</p>
</blockquote>
<p>运行一下你会发现状态栏变成白色了。</p>
<h2 id="设置App的试图">设置App的试图</h2>
<p>是时候实现你的app了，下载必要的图片然后放在合适的地方，这些图片是由Flickr和Dribbble提供的。</p>
<blockquote>
<p><strong>Note:</strong>背景图片是San Francisco的景象，因为这个应用定位的就是这里，你也可以自由定制你的北京图片，比如你的家乡还有其他。</p>
</blockquote>
<p>回到<strong>Xcode</strong>添加图片到app，选中<strong>Copy items into destination group’s folder(if needed)</strong>。</p>
<p>打开<strong>WXController.h</strong>添加以下代理协议：</p>
<blockquote>
<uitableviewdatasource, uitableviewdelegate,="" uiscrollviewdelegate="">

</uitableviewdatasource,></blockquote>
<p>打开<strong>WXController</strong>，你可以通过cmd+ctrl+up在.h,.m文件快速切换。</p>
<p>引入下列文件：</p>
<blockquote>
<p>＃import <lbblurredimage uiimageview+lbblurredimage.h=""></lbblurredimage></p>
</blockquote>
<p><strong>LBBIurredImage.h</strong>在Cocoapods中，你会用它来处理你的背景图片。</p>
<p>在引入下面添加几个空的私有属性：</p>
<blockquote>
<p>@interface WXController ()<br>@property (nonatomic, strong) UIImageView <em>backgroundImageView;<br>@property (nonatomic, strong) UIImageView </em>blurredImageView;<br>@property (nonatomic, strong) UITableView *tableView;<br>@property (nonatomic, assign) CGFloat screenHeight;<br>@end</p>
</blockquote>
<p>是时候创建图片了，也许你会问<strong>IBoutlets</strong>在哪？没关系，我们都会用代码来实现。</p>
<p>等等，别发飙，其实有很多种方法来创建视图个人有各自的偏好，Storyboard,NIBs还有code都有反对和支持者。</p>
<p>这个应用的视图不是很复杂，也没有什么触发事件会导致自动布局异常，而且这个应用是用来学习的，还是选择代码布局。</p>
<p>你会创建三层视图来达到一开始你看的那种动画效果，下面是一个模型，tableview的外观会改变。</p>
<p>为了实现动态模糊效果，在滑动视图的时候需要改alpha</p>
<p>打开<strong>WXController</strong>用下列代码替换<strong> viewDidLoad</strong>中的来设置背景颜色：</p>
<pre><code><span class="comment">// 1</span>
<span class="keyword">self</span><span class="variable">.screenHeight</span> = [UIScreen mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>;

<span class="built_in">UIImage</span> *background = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bg"</span>];

<span class="comment">// 2</span>
<span class="keyword">self</span><span class="variable">.backgroundImageView</span> = [[<span class="built_in">UIImageView</span> alloc] initWithImage:background];
<span class="keyword">self</span><span class="variable">.backgroundImageView</span><span class="variable">.contentMode</span> = UIViewContentModeScaleAspectFill;
[<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.backgroundImageView</span>];

<span class="comment">// 3</span>
<span class="keyword">self</span><span class="variable">.blurredImageView</span> = [[<span class="built_in">UIImageView</span> alloc] init];
<span class="keyword">self</span><span class="variable">.blurredImageView</span><span class="variable">.contentMode</span> = UIViewContentModeScaleAspectFill;
<span class="keyword">self</span><span class="variable">.blurredImageView</span><span class="variable">.alpha</span> = <span class="number">0</span>;
[<span class="keyword">self</span><span class="variable">.blurredImageView</span> setImageToBlur:background blurRadius:<span class="number">10</span> completionBlock:<span class="literal">nil</span>];
[<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.blurredImageView</span>];

<span class="comment">// 4</span>
<span class="keyword">self</span><span class="variable">.tableView</span> = [[<span class="built_in">UITableView</span> alloc] init];
<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;
<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.dataSource</span> = <span class="keyword">self</span>;
<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.separatorColor</span> = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1</span> alpha:<span class="number">0.2</span>];
<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;
[<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.tableView</span>];
</code></pre><p>这是相当简单的一段代码：</p>
<ol>
<li>保存屏幕高度，在接下来呈现天气数据的时候需要用到。</li>
<li>创建一个静态的背景图片，添加到视图。</li>
<li>用LBBLurredImage创建一个模糊背景图，设置alpha为0以至于背景图片是可见的。</li>
<li>创建一个tableview来呈现数据，WXController是代理者，也是scrollview的，注意<strong>pagingEnabled</strong>设置成YES。</li>
</ol>
<p>在<strong>WXController</strong>的<strong>@implementation</strong>部分增加下列代码来实现UITableView的代理</p>
<pre><code><span class="comment">// 1</span>
<span class="preprocessor">#pragma mark - UITableViewDataSource</span>

<span class="comment">// 2</span>
- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView {
    <span class="keyword">return</span> <span class="number">2</span>;
}

- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section {
    <span class="comment">// TODO: Return count of forecast</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}

- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath {
    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"CellIdentifier"</span>;
    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];

    <span class="keyword">if</span> (! cell) {
        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:CellIdentifier];
    }

    <span class="comment">// 3</span>
    cell<span class="variable">.selectionStyle</span> = UITableViewCellSelectionStyleNone;
    cell<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0</span> alpha:<span class="number">0.2</span>];
    cell<span class="variable">.textLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> whiteColor];
    cell<span class="variable">.detailTextLabel</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> whiteColor];

    <span class="comment">// TODO: Setup the cell</span>

    <span class="keyword">return</span> cell;
}

<span class="preprocessor">#pragma mark - UITableViewDelegate</span>

- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath {
    <span class="comment">// TODO: Determine cell height based on screen</span>
    <span class="keyword">return</span> <span class="number">44</span>;
}
</code></pre><p>即使上述代码有些是描述性的，你也能学到一些：</p>
<ol>
<li>Pragma marks 能够很好的帮助组织代码。</li>
<li>你的列表分两段，一段用来播报每小时预告，一段放每日信息，所以每次都返回两段。</li>
<li>预报的cell不能被选中，给它们透明黑的背景和白色的内容。</li>
</ol>
<blockquote>
<p>注意：用标准话的注释。<strong>// TODO:</strong>帮助Xcode找到你需要完成的代码，甚至你还能用Ctrl－6来看TODO元素。</p>
</blockquote>
<p>最后在<strong>WXControlle.m</strong>中加入下列代码：</p>
<pre><code>- (<span class="keyword">void</span>)viewWillLayoutSubviews {
    [<span class="keyword">super</span> viewWillLayoutSubviews];

    <span class="built_in">CGRect</span> bounds = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>;

    <span class="keyword">self</span><span class="variable">.backgroundImageView</span><span class="variable">.frame</span> = bounds;
    <span class="keyword">self</span><span class="variable">.blurredImageView</span><span class="variable">.frame</span> = bounds;
    <span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.frame</span> = bounds;
}
</code></pre><p>试图控制器用上述代码来布局<strong>WXController.m</strong>的子试图。建立并运行来看看你的试图。</p>
<p>仔细看，你会发现有些一些不透明的分割线。仍然在 <strong>-viewDidLoad</strong>加入下列代码来布局：</p>
<pre><code><span class="comment">// 1</span>
<span class="built_in">CGRect</span> headerFrame = [UIScreen mainScreen]<span class="variable">.bounds</span>;
<span class="comment">// 2</span>
<span class="built_in">CGFloat</span> inset = <span class="number">20</span>;
<span class="comment">// 3</span>
<span class="built_in">CGFloat</span> temperatureHeight = <span class="number">110</span>;
<span class="built_in">CGFloat</span> hiloHeight = <span class="number">40</span>;
<span class="built_in">CGFloat</span> iconHeight = <span class="number">30</span>;
<span class="comment">// 4</span>
<span class="built_in">CGRect</span> hiloFrame = CGRectMake(inset, 
                              headerFrame<span class="variable">.size</span><span class="variable">.height</span> - hiloHeight,
                              headerFrame<span class="variable">.size</span><span class="variable">.width</span> - (<span class="number">2</span> * inset),
                              hiloHeight);

<span class="built_in">CGRect</span> temperatureFrame = CGRectMake(inset, 
                                     headerFrame<span class="variable">.size</span><span class="variable">.height</span> - (temperatureHeight + hiloHeight),
                                     headerFrame<span class="variable">.size</span><span class="variable">.width</span> - (<span class="number">2</span> * inset),
                                     temperatureHeight);

<span class="built_in">CGRect</span> iconFrame = CGRectMake(inset, 
                              temperatureFrame<span class="variable">.origin</span><span class="variable">.y</span> - iconHeight, 
                              iconHeight, 
                              iconHeight);
<span class="comment">// 5</span>
<span class="built_in">CGRect</span> conditionsFrame = iconFrame;
conditionsFrame<span class="variable">.size</span><span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span> - (((<span class="number">2</span> * inset) + iconHeight) + <span class="number">10</span>);
conditionsFrame<span class="variable">.origin</span><span class="variable">.x</span> = iconFrame<span class="variable">.origin</span><span class="variable">.x</span> + (iconHeight + <span class="number">10</span>);
</code></pre><p>这是一些很常规的设置，下面是注释：</p>
<ol>
<li>设置列表和屏幕一样大，列表分成头，每日，和每小时预报是有好处的。</li>
<li>创建一个边距变量用来更好的布局你的标签。</li>
<li>创建一系列用来初始化试图的高度变量，设为常量来方便的配置和改变你试图。</li>
<li>用这些常量创建你标签和图标的大小。</li>
<li>拷贝这些图标边框，调整到内容能够有一些扩展的空间，放到原有图标的右边，你会发现这些布局是怎么起作用的。</li>
</ol>
<p>把下列代码拷贝到<strong>-viewDidLoad</strong>中：</p>
<pre><code><span class="comment">// 1</span>
<span class="built_in">UIView</span> *header = [[<span class="built_in">UIView</span> alloc] initWithFrame:headerFrame];
header<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
<span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.tableHeaderView</span> = header;

<span class="comment">// 2</span>
<span class="comment">// bottom left</span>
<span class="built_in">UILabel</span> *temperatureLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:temperatureFrame];
temperatureLabel<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
temperatureLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> whiteColor];
temperatureLabel<span class="variable">.text</span> = <span class="string">@"0°"</span>;
temperatureLabel<span class="variable">.font</span> = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"HelveticaNeue-UltraLight"</span> size:<span class="number">120</span>];
[header addSubview:temperatureLabel];

<span class="comment">// bottom left</span>
<span class="built_in">UILabel</span> *hiloLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:hiloFrame];
hiloLabel<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
hiloLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> whiteColor];
hiloLabel<span class="variable">.text</span> = <span class="string">@"0° / 0°"</span>;
hiloLabel<span class="variable">.font</span> = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"HelveticaNeue-Light"</span> size:<span class="number">28</span>];
[header addSubview:hiloLabel];

<span class="comment">// top</span>
<span class="built_in">UILabel</span> *cityLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">20</span>, <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">30</span>)];
cityLabel<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
cityLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> whiteColor];
cityLabel<span class="variable">.text</span> = <span class="string">@"Loading..."</span>;
cityLabel<span class="variable">.font</span> = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"HelveticaNeue-Light"</span> size:<span class="number">18</span>];
cityLabel<span class="variable">.textAlignment</span> = NSTextAlignmentCenter;
[header addSubview:cityLabel];

<span class="built_in">UILabel</span> *conditionsLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:conditionsFrame];
conditionsLabel<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
conditionsLabel<span class="variable">.font</span> = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"HelveticaNeue-Light"</span> size:<span class="number">18</span>];
conditionsLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> whiteColor];
[header addSubview:conditionsLabel];

<span class="comment">// 3</span>
<span class="comment">// bottom left</span>
<span class="built_in">UIImageView</span> *iconView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:iconFrame];
iconView<span class="variable">.contentMode</span> = UIViewContentModeScaleAspectFit;
iconView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];
[header addSubview:iconView];
</code></pre><p>代码很多，不过也确实做了很多事来设置你多样的试图，简单的解释：</p>
<ol>
<li>再表头设置当前状态。</li>
<li>创建每个需要展现天气的标签。</li>
<li>添加一个用于放置天气图标的图片试图。</li>
</ol>
<p>给列表一个轻推事件，当你滑动时应该有个反弹。</p>
<h3 id="获取天气数据">获取天气数据</h3>
<p>你会发现虽然画面显示了loading，不过没有任何反应，是时候获取一些真实的天气状况啦。</p>
<p>从<strong>OpenWeatherMap</strong>提供的api获取数据。OpenWeatherMap是一个很好的免费为大家提供实时精准的天气数据。它有很多种天气接口，不过大多数是用了类似XML的过时的技术，或者有些是需要付费的，而且很贵。</p>
<p>根据下列步骤来获得天气数据：</p>
<ol>
<li>获取设备地址。</li>
<li>下载json格式的天气数据</li>
<li>匹配数据</li>
<li>通知ui有新的数据</li>
</ol>
<p>先创建天气模型和数据管理类。取名<strong>WXCLient</strong>，继承<strong>NSObject</strong>.</p>
<p>用同样的方式做下列三件事：</p>
<ul>
<li><strong>WXManager</strong>继承<strong>NSObject</strong>。</li>
<li><strong>WXCondition</strong>继承<strong>MTLModel</strong>。</li>
<li><strong>WXDailyForecast</strong>继承<strong>WXConditon</strong>。</li>
</ul>
<p>所有都做完后，可以开始下一个步骤，匹配和转换天气数据模型。</p>
<h3 id="创建天气模型">创建天气模型</h3>
<p>用<strong>Mantle</strong>来让你更简单的实现数据匹配和值转换，打开<strong>WXCondition.h</strong>像下面一样修改接口：</p>
<pre><code><span class="comment">// 1</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">WXCondition</span> : <span class="title">MTLModel</span> &lt;<span class="title">MTLJSONSerializing</span>&gt;</span>

<span class="comment">// 2</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *date;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *humidity;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *temperature;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *tempHigh;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *tempLow;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *locationName;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *sunrise;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *sunset;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *conditionDescription;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *condition;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *windBearing;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *windSpeed;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *icon;

<span class="comment">// 3</span>
- (<span class="built_in">NSString</span> *)imageName;

<span class="keyword">@end</span>
</code></pre><p>同样的，有很多设置代码，跟着注释编号，逐条解释：</p>
<ol>
<li><strong>MTLjsonSetializing</strong>协议用来告诉Mantle这个对象能够把json格式的数据匹配成O_C的属性。</li>
<li>这些是所有的天气数据属性，你会用到一些，不过最好还是全部添加上去能够让你方便的扩展。</li>
<li>一个简单的用于匹配天气状况和图片的方法。</li>
</ol>
<p>运行你会发现出现错误了，你还没有引入<strong>MTLModel.h</strong>文件。重新编译，会出现一些新的警告，忽略就行。</p>
<p>先实现<strong> -imageName</strong>方法，打开<strong>WXCondition.m</strong>添加下列代码：</p>
<pre><code>+ (<span class="built_in">NSDictionary</span> *)imageMap {
    <span class="comment">// 1</span>
    <span class="keyword">static</span> <span class="built_in">NSDictionary</span> *_imageMap = <span class="literal">nil</span>;
    <span class="keyword">if</span> (! _imageMap) {
        <span class="comment">// 2</span>
        _imageMap = @{
                      <span class="string">@"01d"</span> : <span class="string">@"weather-clear"</span>,
                      <span class="string">@"02d"</span> : <span class="string">@"weather-few"</span>,
                      <span class="string">@"03d"</span> : <span class="string">@"weather-few"</span>,
                      <span class="string">@"04d"</span> : <span class="string">@"weather-broken"</span>,
                      <span class="string">@"09d"</span> : <span class="string">@"weather-shower"</span>,
                      <span class="string">@"10d"</span> : <span class="string">@"weather-rain"</span>,
                      <span class="string">@"11d"</span> : <span class="string">@"weather-tstorm"</span>,
                      <span class="string">@"13d"</span> : <span class="string">@"weather-snow"</span>,
                      <span class="string">@"50d"</span> : <span class="string">@"weather-mist"</span>,
                      <span class="string">@"01n"</span> : <span class="string">@"weather-moon"</span>,
                      <span class="string">@"02n"</span> : <span class="string">@"weather-few-night"</span>,
                      <span class="string">@"03n"</span> : <span class="string">@"weather-few-night"</span>,
                      <span class="string">@"04n"</span> : <span class="string">@"weather-broken"</span>,
                      <span class="string">@"09n"</span> : <span class="string">@"weather-shower"</span>,
                      <span class="string">@"10n"</span> : <span class="string">@"weather-rain-night"</span>,
                      <span class="string">@"11n"</span> : <span class="string">@"weather-tstorm"</span>,
                      <span class="string">@"13n"</span> : <span class="string">@"weather-snow"</span>,
                      <span class="string">@"50n"</span> : <span class="string">@"weather-mist"</span>,
                      };
    }
    <span class="keyword">return</span> _imageMap;
}

<span class="comment">// 3</span>
- (<span class="built_in">NSString</span> *)imageName {
    <span class="keyword">return</span> [WXCondition imageMap][<span class="keyword">self</span><span class="variable">.icon</span>];
}
</code></pre><p>解释一下：</p>
<ol>
<li>创建一个静态的NSDictionary用于存放<strong>WXConditon</strong></li>
<li>匹配每一种状态。</li>
<li>声明一个消息来获得图像名称。</li>
</ol>
<p>仍然在这个文件中声明一个遵循<strong>MTLJSONSerializing</strong>协议的<strong> +JSONKeyPathsByPropertyKey</strong>方法用于匹配json格式的数据。</p>
<pre><code>+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey {
    <span class="keyword">return</span> @{
             <span class="string">@"date"</span>: <span class="string">@"dt"</span>,
             <span class="string">@"locationName"</span>: <span class="string">@"name"</span>,
             <span class="string">@"humidity"</span>: <span class="string">@"main.humidity"</span>,
             <span class="string">@"temperature"</span>: <span class="string">@"main.temp"</span>,
             <span class="string">@"tempHigh"</span>: <span class="string">@"main.temp_max"</span>,
             <span class="string">@"tempLow"</span>: <span class="string">@"main.temp_min"</span>,
             <span class="string">@"sunrise"</span>: <span class="string">@"sys.sunrise"</span>,
             <span class="string">@"sunset"</span>: <span class="string">@"sys.sunset"</span>,
             <span class="string">@"conditionDescription"</span>: <span class="string">@"weather.description"</span>,
             <span class="string">@"condition"</span>: <span class="string">@"weather.main"</span>,
             <span class="string">@"icon"</span>: <span class="string">@"weather.icon"</span>,
             <span class="string">@"windBearing"</span>: <span class="string">@"wind.deg"</span>,
             <span class="string">@"windSpeed"</span>: <span class="string">@"wind.speed"</span>
             };
}
</code></pre><p>在这个例子中，dictionary的key就是<strong>WXCondition</strong>的属性，dictionary的value就是json的值。</p>
<p>你会发现从JSON数据匹配到O_C属性有些冲突，比如说属性 date是NSDate类型的，而JSON的是整型的。这时就需要进行一些转换。</p>
<p>Mantle的一个特性能解决这个问题：<strong>MTLValueTransformer</strong>。这个类让你声明一个块解决怎么转换值。</p>
<p>Mantle转换的语法有一点点奇怪，给特殊的属性写一个转换函数，创建一个以属性名字开始以<strong>JSONTransformer</strong>结尾的类方法。</p>
<p>看比解释更直观，所以加上下列代码到<strong>WXCondition.m</strong></p>
<pre><code>+ (NSValueTransformer *)dateJSONTransformer {
    <span class="comment">// 1</span>
    <span class="keyword">return</span> [MTLValueTransformer reversibleTransformerWithForwardBlock:^(<span class="built_in">NSString</span> *str) {
        <span class="keyword">return</span> [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:str<span class="variable">.floatValue</span>];
    } reverseBlock:^(<span class="built_in">NSDate</span> *date) {
        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%f"</span>,[date timeIntervalSince1970]];
    }];
}

<span class="comment">// 2</span>
+ (NSValueTransformer *)sunriseJSONTransformer {
    <span class="keyword">return</span> [<span class="keyword">self</span> dateJSONTransformer];
}

+ (NSValueTransformer *)sunsetJSONTransformer {
    <span class="keyword">return</span> [<span class="keyword">self</span> dateJSONTransformer];
}
</code></pre><p>下面是注释：</p>
<ol>
<li>用代码快转换值返回一个<strong>MTLValueTransformers</strong>值</li>
<li>你只需要知道一次怎么转换，其他可以复用。</li>
</ol>
<p>下一个值转换有点难理解，不过是一个简单的使用OpenWeatherMap的接口然后进行值转换的结果。天气值是一个JSON格式的数组，不过你只需要关注其中的一条。</p>
<p>用上诉方法，添加下列代码来实现：</p>
<pre><code>+ (NSValueTransformer *)conditionDescriptionJSONTransformer {
    <span class="keyword">return</span> [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSArray *values) {
        <span class="keyword">return</span> [values firstObject];
    } reverseBlock:^(NSString *<span class="keyword">str</span>) {
        <span class="keyword">return</span> @[<span class="keyword">str</span>];
    }];
}

+ (NSValueTransformer *)conditionJSONTransformer {
    <span class="keyword">return</span> [<span class="keyword">self</span> conditionDescriptionJSONTransformer];
}

+ (NSValueTransformer *)iconJSONTransformer {
    <span class="keyword">return</span> [<span class="keyword">self</span> conditionDescriptionJSONTransformer];
}
</code></pre><p>最后一个转换只是一种习俗，接口提供的风速是m/s，考虑到你的系统是英式风格，转换成里没小时。添加下列方法和宏定义到<strong>WXConditon.m</strong>里。</p>
<pre><code><span class="comment">#define MPS_TO_MPH 2.23694f</span>

+ (NSValueTransformer <span class="keyword">*</span>)windSpeedJSONTransformer {
    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSNumber <span class="keyword">*</span>num) {
        return <span class="comment">@(num.floatValue*MPS_TO_MPH);</span>
    } reverseBlock:^(NSNumber <span class="keyword">*</span>speed) {
        return <span class="comment">@(speed.floatValue/MPS_TO_MPH);</span>
    }];
}
</code></pre><p>你需要处理的天气接口数据有一点点的小差异，注意下实时情况和每日预报的数据：</p>
<pre><code><span class="comment">// current</span>
<span class="string">"main"</span>: {
    <span class="string">"grnd_level"</span>: <span class="number">1021.87</span>,
    <span class="string">"humidity"</span>: <span class="number">64</span>,
    <span class="string">"pressure"</span>: <span class="number">1021.87</span>,
    <span class="string">"sea_level"</span>: <span class="number">1030.6</span>,
    <span class="string">"temp"</span>: <span class="number">58.09</span>,
    <span class="string">"temp_max"</span>: <span class="number">58.09</span>,
    <span class="string">"temp_min"</span>: <span class="number">58.09</span>
}

<span class="comment">// daily forecast</span>
<span class="string">"temp"</span>: {
    <span class="string">"day"</span>: <span class="number">58.14</span>,
    <span class="string">"eve"</span>: <span class="number">58.14</span>,
    <span class="string">"max"</span>: <span class="number">58.14</span>,
    <span class="string">"min"</span>: <span class="number">57.18</span>,
    <span class="string">"morn"</span>: <span class="number">58.14</span>,
    <span class="string">"night"</span>: <span class="number">57.18</span>
}
</code></pre><p>实时的第一个健是main最高温度是temp_max而预报的是temp和max，除了这其他都一样，所以需要改变健名来匹配正确，打开<strong>WXDaikyForecast.m</strong>重写<strong>JSONKeyPathsByPropertyKey</strong>方法：</p>
<pre><code>+ (<span class="built_in">NSDictionary</span> *)JSONKeyPathsByPropertyKey {
    <span class="comment">// 1</span>
    <span class="built_in">NSMutableDictionary</span> *paths = [[<span class="keyword">super</span> JSONKeyPathsByPropertyKey] mutableCopy];
    <span class="comment">// 2</span>
    paths[<span class="string">@"tempHigh"</span>] = <span class="string">@"temp.max"</span>;
    paths[<span class="string">@"tempLow"</span>] = <span class="string">@"temp.min"</span>;
    <span class="comment">// 3</span>
    <span class="keyword">return</span> paths;
}
</code></pre><p>这也会覆盖WXCondition的方法，下面是注释：</p>
<ol>
<li>获得<strong>WXCondition</strong>的复制</li>
<li>改变最大和最小健名来匹配每日预报</li>
<li>返回一个新的映射</li>
</ol>
<p>编译一下确保没有错。</p>
]]></content>
    <summary type="html"><![CDATA[<h3 id="写在开头的话">写在开头的话</h3>
<p>整整三个礼拜，曾自信的以为能够翻译全文的，结果还是只完成了上半部分，中间断断续续，不管怎么说还是坚持了下来。就是图片没有，可以参考<a href="http://www.raywenderlich.com/55384/ios-7-best-practices-part-1" target="_blank" rel="external">译文</a> </p>
<p>发现看懂英文和翻译成比较顺口的文章还是有差别的，希望以后能够大大的提高自己的英语口语水平。</p>
<p>还有上次说的ruby计划已经泡汤，不知道合适才能重拾ruby，下一次准备发一篇对设计模式的理解，和最近再研究的<strong>reactivecocoa</strong></p>
<p><a href="http://www.raywenderlich.com/55384/ios-7-best-practices-part-1" target="_blank" rel="external">译文</a> 作者：Ryan Nystrom</p>
<p>]]></summary>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建个人博客最佳实践]]></title>
    <link href="http://tracyone.com/2014/07/27/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://tracyone.com/2014/07/27/搭建个人博客最佳实践/</id>
    <published>2014-07-27T06:17:28.000Z</published>
    <updated>2014-08-16T04:13:12.000Z</updated>
    <content type="html"><![CDATA[<p>只有闲得蛋疼的人才会想自己搞一个博客，好好的一个周末又浪费在pc上，所幸成功了，现分享出来装下x。</p>
<h3 id="准备工作">准备工作</h3>
<ol>
<li>安装git</li>
<li>安装Node.js</li>
<li>安装hexo<br><a id="more"></a><br>跳过。。。。。。</li>
</ol>
<h3 id="干货">干货</h3>
<h4 id="在github上创建repository">在github上创建repository</h4>
<p>在自己Github主页右下角，创建一个新的repository。比如我的Github账号是soochowtracy，那么我应该创建的repository名字应该是soochowtracy.tracyone.com。</p>
<p><img src="http://ww2.sinaimg.cn/large/7cff62c6gw1eir9vlmxm8j20ri08st9i.jpg" alt="Alt text"></p>
<h4 id="创建hexo文件">创建hexo文件</h4>
<p>在终端中输入</p>
<ul>
<li>mkdir hexo</li>
<li>cd hexo</li>
<li>hexo init</li>
<li>npm install</li>
</ul>
<h4 id="部署上去吧少年">部署上去吧少年</h4>
<p>编辑_config.yml。你在部署时，要把下面的<strong>tracyone</strong>都换成你的账号名。</p>
<pre><code>deploy:
  <span class="class"><span class="keyword">type</span>: <span class="title">github</span></span>
  repository: https:<span class="comment">//github.com/soochowtracy/tracyone.git</span>
</code></pre><p>执行下列指令就o啦：</p>
<ul>
<li>hexo g</li>
<li>hexo d</li>
</ul>
<h4 id="来一发">来一发</h4>
<p>搭好了该干点什么呢？？？来一发吧，通过<strong>hexo new blogtitle</strong>，自动会在_post目录下生成，然后用markdown语法写你的博客吧（下次有机会再介绍markdown）。</p>
<h4 id="替换皮肤中。。。">替换皮肤中。。。</h4>
<p>每个人都有追求美的权利，hexo当然也有，为此很多程序员为之不懈努力，推荐一个hexo皮肤源<strong><a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/tommy351/hexo/wiki/Themes</a></strong>。下好了放在theme目录下。最后再_config.yml中把theme: 改成 theme: xxxxx。</p>
<h3 id="Q&amp;A">Q&amp;A</h3>
<p>Q:我怎么访问这么慢呀？？？？<br>A:国情问题，不过没关系360有自己的字体。只需把文件中所有的useso改成useso。</p>
<p>Q:我还是不能访问阿？？？？<br>A:域名解析有问题阿。昨天搞了我一天现特贴图：<br><img src="http://ww1.sinaimg.cn/large/7cff62c6gw1eirbo3aiv8j21k60eo76i.jpg" alt="Alt text"></p>
<h3 id="总结">总结</h3>
<p>我发现这篇写的好水啊。下次有机会出一篇史诗级的，今天实在太忙了！！！<br>最后列一下接下来准备学习的清单：</p>
<ol>
<li>ios (design pattern)</li>
<li>swift</li>
<li>ruby (not rail)</li>
</ol>
<p>昨天初探了下ruby，解释型语言就是牛，写一行执行一行的感觉不要太酸爽。</p>
]]></content>
    <summary type="html"><![CDATA[<p>只有闲得蛋疼的人才会想自己搞一个博客，好好的一个周末又浪费在pc上，所幸成功了，现分享出来装下x。</p>
<h3 id="准备工作">准备工作</h3>
<ol>
<li>安装git</li>
<li>安装Node.js</li>
<li>安装hexo<br>]]></summary>
    
      <category term="hexo" scheme="http://tracyone.com/tags/hexo/"/>
    
      <category term="Hexo" scheme="http://tracyone.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[工作一个月总结（再加上一点点iOS心得）]]></title>
    <link href="http://tracyone.com/2014/07/26/%E5%B7%A5%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%9C%88%E6%80%BB%E7%BB%93%EF%BC%88%E5%86%8D%E5%8A%A0%E4%B8%8A%E4%B8%80%E7%82%B9%E7%82%B9iOS%E5%BF%83%E5%BE%97%EF%BC%89/"/>
    <id>http://tracyone.com/2014/07/26/工作一个月总结（再加上一点点iOS心得）/</id>
    <published>2014-07-26T13:23:01.000Z</published>
    <updated>2014-08-06T12:27:54.000Z</updated>
    <content type="html"><![CDATA[<p>转眼间大学已经毕业，总是伴着些许忧桑，其实也还好，离家很近。细数过往发现，其实我从没走出过家乡，小学、初中、高中、甚至是大学，最远的最远竟是苏州城里－－也算是进城了。</p>
<p>踏入社会的的滋味复杂而苦涩，总是伴随着挫折渐渐成长，总结下这一年实习和一个月工作所得所失：</p>
<h3 id="像一个成年人去思考">像一个成年人去思考</h3>
<p>犹记得刚实习时，像个愣头青，习惯了口无遮拦，习惯了懒散的纪律观念，习惯了12月早上8点暖和的被窝，突然间一切都变了。</p>
<p>再这里，你就得把自己当一条狗，你什么都不是，没有什么资本值得你去炫耀，你需要做的就是努力再努力的工作。公司和学校最本质的区别是：<strong>你给学校钱，而公司却给你钱！</strong> 你已经是一个成年人了，别伤感，只是说了个事实。</p>
<a id="more"></a>

<h3 id="勾心斗角总是免不了的">勾心斗角总是免不了的</h3>
<p>最近悟出了个道理，。。。。。。。。。。。。这就是道理！</p>
<p>人生本充满困难的（life is difficult），只不过有些人选择承受面对困难带来痛苦，有些人选择承受逃避困难带来的痛苦。当你深处生活的漩涡痛苦不已不能自拔的时候，你应该意识到这只不过是你选择了随波逐流人云亦云的生活带来痛苦而已，人世间没有哪条路是绝对的坦途。</p>
<h3 id="送三条博弈论经典真理">送三条博弈论经典真理</h3>
<ol>
<li>Don’t play a strictly dominated strategy </li>
<li>Rational choice can lead to bad outcomes</li>
<li>Put yourself in other people’s shoes</li>
</ol>
<p>别问我为什么没翻译成中文，英语只有6级的渣怕无人前途。</p>
<h3 id="重头戏来了！！！！">重头戏来了！！！！</h3>
<p>是时候来点干货了，其实我工作也蛮坎坷的，一会做Aurora，一会做HTML5，现在又搞起了ios,真是够折腾的。</p>
<h4 id="从登录界面说起">从登录界面说起</h4>
<p>界面无非那些组件，个人感觉人机交互比较重要，必要的提示和校验总能让人眼前一亮，推荐个输入框抖动效果 </p>
<pre><code><span class="keyword">if</span> (<span class="keyword">self</span>.userNameTF.text.length == <span class="number">0</span>) {
        [<span class="keyword">self</span> <span class="symbol">lockAnimationForView:</span><span class="keyword">self</span>.userNameTF];
    }
<span class="keyword">if</span> (<span class="keyword">self</span>.passwordTF.text.length == <span class="number">0</span>) {
        [<span class="keyword">self</span> <span class="symbol">lockAnimationForView:</span><span class="keyword">self</span>.passwordTF];
    }
</code></pre><p>登录的过程总是伴随着校验，总不能让用户干等着吧，推荐个做的效果比较赞的指示器<a href="https://github.com/mutualmobile/MMProgressHUD" target="_blank" rel="external">MMProgressHUD</a>。再给个实例：</p>
<pre><code>    <span class="built_in">BOOL</span> autodismiss = <span class="literal">YES</span>;
    <span class="built_in">CGFloat</span> red =  arc4random_uniform(<span class="number">255</span>)/<span class="number">255.</span>f;
    <span class="built_in">CGFloat</span> blue = arc4random_uniform(<span class="number">256</span>)/<span class="number">255.</span>f;
    <span class="built_in">CGFloat</span> green = arc4random_uniform(<span class="number">256</span>)/<span class="number">255.</span>f;
    CGColorRef color = CGColorRetain([<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>]<span class="variable">.CGColor</span>);
    [[[MMProgressHUD sharedHUD] overlayView] setOverlayColor:color];
    CGColorRelease(color);
    [MMProgressHUD showWithTitle:<span class="string">@"Overlay"</span> status:<span class="string">@"Random Color"</span>];

    <span class="keyword">if</span> (autodismiss == <span class="literal">YES</span>) {
        <span class="keyword">double</span> delayInSeconds = <span class="number">2.5</span>;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
        dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>){
            [MMProgressHUD dismissWithSuccess:<span class="string">@"Success!"</span>];
        });
    }
</code></pre><h4 id="一些小小的tips">一些小小的tips</h4>
<ul>
<li>获取设备编号</li>
</ul>
<pre><code><span class="constant">UIDevice *device</span> = [UIDevice currentDevice];
<span class="constant">NSUUID *uniqueIdentifier</span> = device.identifierForVendor;
</code></pre><ul>
<li>tableView选择风格</li>
</ul>
<pre><code>(UITableViewCellEditingStyle)tableView:(<span class="built_in">UITableView</span> *)tableView editingStyleForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="keyword">return</span> UITableViewCellEditingStyleDelete | UITableViewCellEditingStyleInsert;
}
</code></pre><ul>
<li>排序：</li>
</ul>
<pre><code> NSArray *sortDesc = @<span class="string">[[[NSSortDescriptor alloc] initWithKey:nil ascending:NO]]</span>;
 NSArray *sortSetArray = [timeset sortedArrayUsingDescriptors:sortDesc];
</code></pre><ul>
<li>字符串比较：</li>
</ul>
<pre><code><span class="keyword">if</span> ([weekDate <span class="keyword">compare</span>:[record objectForKey:@<span class="string">"expense_date"</span>]] == -<span class="number">1</span>)
</code></pre><h4 id="反编译地址经典教程">反编译地址经典教程</h4>
<pre><code>CGFloatlat=<span class="number">30.0</span>;CGFloatlng=<span class="number">120.0</span>;
CLGeocoder*coder=[[CLGeocoderalloc]init];
CLLocation*mapLocation=[[CLLocationalloc]initWithLatitude:latlongitude:lng];

[coderreverseGeocodeLocation:mapLocationcompletionHandler:^(<span class="built_in">NSArray</span>*placemarks,<span class="built_in">NSError</span>*error){
<span class="keyword">if</span>(error){
<span class="comment">// Geocoder failed.</span>
}
<span class="keyword">else</span>{
CLPlacemark*mapPlaceName=[placemarksobjectAtIndex:<span class="number">0</span>];
<span class="built_in">NSString</span>*stateName=[mapPlaceNameadministrativeArea];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,stateName);
}
}];

intmain(intargc,<span class="keyword">char</span>*argv[])
{
<span class="keyword">@autoreleasepool</span>{
<span class="comment">// 强制简体中文</span>
[[NSUserDefaultsstandardUserDefaults]setObject:[NSArrayarrayWithObjects:<span class="string">@"zh-Hans"</span>,<span class="literal">nil</span>]
forKey:<span class="string">@"AppleLanguages"</span>];
[[NSUserDefaultsstandardUserDefaults]synchronize];
returnUIApplicationMain(argc,argv,<span class="literal">nil</span>,NSStringFromClass([AppDelegateclass]));
}
}
</code></pre><h3 id="题外话">题外话</h3>
<p>第一次写这么长的博客，其实写博客到没花多少时间，素材每天都再收集，不过搭建博客的过程略心酸。下一篇准备把怎么搭建这个博客攻略分享！！！力求做到每个非技术的兄弟们都能搭建起来自己的博客。</p>
]]></content>
    <summary type="html"><![CDATA[<p>转眼间大学已经毕业，总是伴着些许忧桑，其实也还好，离家很近。细数过往发现，其实我从没走出过家乡，小学、初中、高中、甚至是大学，最远的最远竟是苏州城里－－也算是进城了。</p>
<p>踏入社会的的滋味复杂而苦涩，总是伴随着挫折渐渐成长，总结下这一年实习和一个月工作所得所失：</p>
<h3 id="像一个成年人去思考">像一个成年人去思考</h3>
<p>犹记得刚实习时，像个愣头青，习惯了口无遮拦，习惯了懒散的纪律观念，习惯了12月早上8点暖和的被窝，突然间一切都变了。</p>
<p>再这里，你就得把自己当一条狗，你什么都不是，没有什么资本值得你去炫耀，你需要做的就是努力再努力的工作。公司和学校最本质的区别是：<strong>你给学校钱，而公司却给你钱！</strong> 你已经是一个成年人了，别伤感，只是说了个事实。</p>
]]></summary>
    
      <category term="ios" scheme="http://tracyone.com/tags/ios/"/>
    
      <category term="IOS" scheme="http://tracyone.com/categories/IOS/"/>
    
  </entry>
  
</feed>
